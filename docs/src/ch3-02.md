# C++: 0 到 15

## 本节目录

- [C++: 0 到 15](#c-0-到-15)
  - [本节目录](#本节目录)
  - [0 - 格式化输出](#0---格式化输出)
  - [1 - 变量与运算符](#1---变量与运算符)
  - [2 - 函数、声明和定义](#2---函数声明和定义)
  - [3 - 形参和实参](#3---形参和实参)
  - [4 - static 关键字](#4---static-关键字)
  - [5 - constexpr 编译时常量和运算 - 实现递归 Fibonacci 数列](#5---constexpr-编译时常量和运算---实现递归-fibonacci-数列)
  - [6 - 循环 与 记忆化](#6---循环-与-记忆化)
  - [7 - 枚举和联合体](#7---枚举和联合体)
  - [8 - “普通”类型：结构体](#8---普通类型结构体)
  - [9 - 结构体内的方法](#9---结构体内的方法)
  - [10 - const 关键字 与 const 修饰方法](#10---const-关键字-与-const-修饰方法)
  - [11 - 类：class 的引入](#11---类class-的引入)
  - [12 - 构造函数和析构函数](#12---构造函数和析构函数)
  - [13 - 复制构造](#13---复制构造)
  - [14 - 移动构造器](#14---移动构造器)
  - [15 - 派生 / 继承](#15---派生--继承)

## 0 - 格式化输出

要求在控制台输出 `Hello, InfiniTensor`，主要涉及到`标准输出流`和`C++ 换行符`。

## 1 - 变量与运算符

要求在控制台，打印出一条加法运算得到的结果和式子本身，主要需要注意`C++ 里的运算符`。

## 2 - 函数、声明和定义

尝试完成“加法运算”的函数，只需要掌握极少量的传参的知识。

**高级操作：当在加法运算前加一个`static`标签时，会发生什么？怎么解决？为什么会这样？**

## 3 - 形参和实参

ASSERT 宏是一个“断言”，只有内部条件为 True 时，才能继续执行代码，否则会报错并终止程序，报错信息可以自定义。

请根据对“形参和实参”的学习，正确补充 ASSERT 宏内的内容，使代码正确运行。

## 4 - static 关键字

`static` 关键字有着不同的作用，请在学习后，正确补充 ASSERT 宏内的内容，使代码正确运行。

## 5 - constexpr 编译时常量和运算 - 实现递归 Fibonacci 数列

本题要求实现一个递归函数，计算斐波那契数列的第 n 项，主要涉及到`递归`和`函数`。

现在的代码中，有一个 `constexpr` 关键字。`constexpr` 关键字是 C++11 新增的，用于声明一个常量表达式，即编译期就能确定的值。但是为了保证代码的健壮性，**`constexpr`** 声明的表达式，如果是递归的，那么必须**限制其深度**，否则编译器会报错。

请根据对“constexpr”的学习，正确补充 ASSERT 宏内的内容，使代码正确运行。

## 6 - 循环 与 记忆化

本题要求为刚刚的递归，实现记忆化。

记忆化是一种针对算法时间复杂度进行优化的技术，通过存储已经计算过的结果，避免重复计算，从而提高程序效率。而在进行存储时，一般可以使用数组、Hash 表等数据结构。

请根据对“记忆化”与“循环”的学习，正确补充 ASSERT 宏内的内容，使代码正确运行。

## 7 - 枚举和联合体

本题要求使用联合体存储两个枚举的内容，并使其能够互相进行转换。

请根据对“枚举和联合体”的学习，正确补充 ASSERT 宏内的内容，使代码正确运行。

## 8 - “普通”类型：结构体

在 “记忆化” 这一题，我们使用了数组进行存储。但问题是，实际上，我们需要较大数的 Fibonacci 数列的可能性很小，但确实存在。这种情形下，我们需要“动态计算”所需要内容的 Fibonacci。

此题要求，将数组，改为用结构体进行包裹，以便我们进行进一步的扩展。请根据对“结构体”的学习，正确补充 ASSERT 宏内的内容，使代码正确运行。

**注：结构体要初始化，且做题时，需要注意传入的参数名称和实际含义是否匹配！**

**高级操作：做对的同学想一想，你的实现方式麻烦吗？代码优雅吗？能改进吗？**

## 9 - 结构体内的方法

在面向对象编程中，我们常常将一些函数放在类中，称为方法，以便于我们进行调用。但在 C++ 中，我们也可以将方法放在结构体中，以便于我们进行调用。

此题要求，将上一问的结构体外的函数，移入结构体，并使代码能够正常运行。请根据对“结构体内的方法”的学习，正确补充 ASSERT 宏内的内容，使代码正确运行。

## 10 - const 关键字 与 const 修饰方法

在 C++ 中，`const` 关键字用于声明一个常量，即一旦被初始化，就不能再被修改的变量。但其用在方法上时，根据其修饰的内容不同，有着不同的作用。

我们上一问做的结构体方法，是不支持在一个 `const` 结构体上被调用的，但实际情况下，为了避免编程时的犯错，我们很可能需要 `const` 某个结构体，那么如何使对应的方法允许被 `const` 对象调用呢？

请根据对“const 关键字”的学习，正确补充 ASSERT 宏内的内容，使代码正确运行。

## 11 - 类：class 的引入

C++ 中，`class` 和 `struct` 之间的**唯一区别**是，`class` 默认访问控制符是 `private`，而`struct` 默认访问控制符是 `public`。那么，在这一题，我们将刚刚的结构体，改为 `class`，并使代码能够正常运行。

请根据对“class 的引入”的学习，正确补充 ASSERT 宏内的内容，使代码正确运行。

## 12 - 构造函数和析构函数

在 C++ 中，`析构函数` 是一种特殊的成员函数，用于在对象被销毁时执行一些清理工作。例如，释放动态分配的内存，关闭文件等。

我们的 Fibonacci 类愈发完善，但现在有个小问题，它是定长的。那这在实际环境下，就可能不是很灵活，所以我们在此题，将其改为动态的，即根据需要，动态分配内存。那么就需要 `new` 关键字。

而正因为我们使用了 `new` 关键字动态分配了内存，但在程序结束时，我们没有释放这块内存，这会导致内存泄漏。因此，我们需要在 `class` 中添加一个析构函数，用于释放内存。

请根据对“构造函数”和“析构函数”的学习，正确补充 ASSERT 宏内的内容，使代码正确运行。

**注：看一下“成员初始化列表”的相关知识点。**

## 13 - 复制构造

有很多时候，我们需要复制一个对象。例如，当我们需要将一个对象作为参数传递给函数时，就需要复制这个对象(感兴趣可以去学习“深拷贝”和“浅拷贝”)。而 C++ 中，默认的复制构造函数，只是简单地复制了对象的成员变量，这可能会导致一些问题，例如，如果成员变量是指针，那么复制后的对象和原对象会指向同一块内存，这可能会导致内存泄漏。

因此，我们需要自己实现一个复制构造函数，用于复制对象。而实现复制构造函数时，我们需要注意，如果成员变量是指针，那么我们需要先分配新的内存，然后将原对象的指针指向新的内存，否则会导致内存泄漏。

请根据对“复制构造”的学习，正确补充 ASSERT 宏内的内容，使代码正确运行。

**注：一种“复制”方法是，使用 std::copy，可以自行参考其文档。**

## 14 - 移动构造器

在 C++11 中，引入了一种新的构造函数，称为移动构造函数。移动构造函数用于将一个对象的所有资源移动到另一个对象中，而不是复制。这可以避免不必要的复制，从而提高程序的性能。

请根据对“移动构造器”的学习，正确补充 ASSERT 宏内的内容，使代码正确运行。

**注：移动的本质，是"ctrl + x" 和 "ctrl + v"。对于是指针的成员来说，其指针指向的地址应该变化，但对于类的地址，可未必需要变化**

**注：可能需要之前题目学过的某些知识。**

## 15 - 派生 / 继承

在 C++ 中，派生 / 继承是一种机制，允许一个类（称为派生类，也称为子类）继承另一个类（称为基类，或者叫父类）的成员。派生类可以继承基类的所有成员，包括成员变量和成员函数。

请根据对“派生”的学习，正确补充 ASSERT 宏内的内容，使代码正确运行。

**注：你需要关注继承时，构造函数调用的“顺序问题”。大致是，“尊老爱幼”，即，先做父类(老)，再做成员(幼)，最后自己。**

**还有析构函数的调用顺序，析构函数区别于构造，多了子类的问题。大致是“老”和“幼”顺序互换，最先处理派生类(子类)：先做派生类的析构，再做成员，之后父类，最后自己**
